# Отчет по лабораторной работе №1

**Мой вариант:**

1. `baaa → aaab`
2. `aabb → abab ` 
3. `aa → bab`
4. `aaab → ab`
5. `bbb → b`

## 1) Система не завершима

Возьмем три правила:

1. `baaa → aaab`
2. `aaab → ab ` 
3. `aa → bab`

Применим к левым частям 1 и 2 правила третье правило, получим:

1. `babab → aaab`
2. `bbaba → aaab`
3. `babab → ab`
4. `ababb → ab`
5. `aa → bab`

Теперь по аналогии с предыдущим действием применим к левой части первого правила третье правило, получим:

`ab → aaab`

`babab → ab`

Первое правило образует цикл, следовательно, система не завершима.

### Локальная конфлюэнтность — нет.

Покажем неоднозначно сходящуюся критическую пару:

Рассмотрим строку `u = baaab`. К ней можно применить два разных правила:

- `u = b(aaab) → b(ab) = bab` (по правилу : `aaab → ab`)
- `u = (baaa)b → (aaab)b = aaabb` (по правилу : `baaa → aaab`)

Получаем:
`u → v = bab` 
`u → w = aaabb` 

Продолжим редукцию полученных строк:

- `v = bab → aa` (по правилу : `bab → aa`). Строка `aa` является нормальной формой.
- `w = aaabb → abb` (по правилу : `aaab → ab`). Строка `abb` является нормальной формой.

Итак, имеем:
`v →∗ aa`
`w →∗ abb`

Нормальные формы `aa` и `abb` не равны. Следовательно, система не является локально конфлюэнтной.

## 2) Конечность

Чтобы упростить задачу, я принял фундированный порядок — лексикографический порядок получил:

1. `baaa → aaab`
2. `abab → aabb`
3. `bab → aa`
4. `aaab → ab`
5. `bbb → b`

Далее я написал алгоритм пополнения правил по Кнуту–Бендиксу, он находится в [ReplenishmentAlgorithm](ReplenishmentAlgorithm/src/main.ts). Применив его, получил следующую систему:

1. `baaa → aaab`
2. `abab → aabb`
3. `bab → aa`
4. `aaab → ab`
5. `bbb → b`
6. `aaa → aa`
7. `abb → aa`
8. `bbaa → aa`
9. `aab → ab`
10. `baa → ab`
11. `aba → ab`
12. `abaa → ab`
13. `aabb → aaa`

Далее минимизирую данную систему. Очевидно, что минимизировать правила длиной 3 нельзя, поэтому рассмотрим только правила 1, 2, 4, 8, 12, 13.

**1:** `baaa → aaab` — к данным правилу мы можем применить новые правила как к левой части так и к правой. Приведем к НФ левую и правую часть. `baaa -> baa -> ab`, правая часть `aaab -> aab -> ab` т.е очевидно правило 1 сокращается .

**2:** `abab → aabb` — аналогично правилу 2 приведем к НФ. Левая часть `abab -> abb -> aa`, правая часть `aabb -> abb -> aa` т.е очевидно правило 2 сокращается .

**4:** `aaab → ab` — можем применить правило 9, получим `aab → ab`. Это и есть правило 9, следовательно, правило 4 сокращается.

**8:** `bbaa → aa` — можем применить правило 10, получим `bab → aa`. Это правило 3, следовательно, правило 8 сокращается.

**12:** `abaa → ab `— применяем правило 11, получим `aba → ab`. Это и есть правило 11, следовательно, правило 12 сокращается.

**13:** `aabb → aaa` — применяется правило 7, получим `aaa → aaa`, следовательно, правило 13 сокращается.

### Итог: финальная минимизированная система имеет вид:

1. `bab → aa`
2. `bbb → b`
3. `aaa → aa`
4. `abb → aa`
5. `aab → ab`
6. `baa → ab`
7. `aba → ab`

### Построим дерево

![Дерево переписываний](TFL_Tree.png)

Как мы видим, все конечные вершины дерева переписываются по какому-либо правилу, следовательно, система конечна!

## 3) Фаззинг-тестирование

Немного поменял код, теперь, мы получаем НФ1 с помощью T, затем получаем НФ2 с помощью T', затем проверяю могу ли я получить из НФ1 НФ2 и наоброт с помощью T'
[FuzzingTest](FazzingTest/src/main.ts)

## 4) Инварианты

Удалось найти только два тривиальных инварианта:

1. Чётность количества символов '`b`'

2. (количество_символов_`a` + длина_строки) mod 2

[MetamorfTest](MetamorfTest/src/main.ts)